# 尺取法（双指针法）

若区间单调，常用二分法

本质是将二重循环变为单循环

## 反向扫描

- 找指定和的整数对：就是两个指针的移动，可以类似于快排

- 判断回文串也是如此

## 同向扫描

- 寻找区间和

```c++
void findsun(int *a,int n,int s){
    int i=0,j=0;
    int sum=a[0];
    while(j<n){
        if(sum>=s){
            if(sum==s)cout<<i<<j;//sum=>s那么就移动i
            sum-=a[i];
            i++;
            if(i>j){sum=a[i];j++}
        }
        if(sum<s){j++;sum+=a[j];}//sum<s就移动j
    }
}
```

- 数组去重

​			1.哈希法，插入哈希表看是否冲突

​			2.尺取法：

​			 （1）将数组排序，排序后重复的整数会挤在一起。

​			 （2）定义双指针i和j，初始都指向a[0]。i和j都从头到尾扫描数组a[]。i指针走得快，逐个遍历整个;j指针走得慢，它始终指向当前不重复部分的最后一个数。j用于获得不重复的数。

​			 （3）扫描数组。快指针执行i++,如果a[i]不等于慢指针j指向的a[j]，就执行j++，并且把a[i]复制到慢指针j的当前位置a[j]。

​			 （4）i扫描结束后，a[0]~a[j]就是不重复数组。

- 多指针	

```
#include<bits/stdc++.h>
using namespace std;
const int N=2e5 +5;
int a[N];
int main(){
	int n,c;
	cin>>n>>c;
	for(int i=1;i<=n;i++)cin>>a[i];
	sort(a+1,a+1+n);
	long long ans=0;
	for(int i=1,j=1,k=1;i<=n;i++){
	  while(j<=n && a[j]-a[i]<c)j++;//用于j和k查找数字相同的区间
	  while(k<=n && a[k]-a[i]<=c)k++;//区间[j,k]内所有数字相同
	  if(a[j]-a[i]==c && a[k-1]-a[i]==c && k-1>=1)ans+=k-j;
	}
	cout<<ans;
	return 0;
}
```

​	还有二分法、STL map等。
