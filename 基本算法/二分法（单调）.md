# 二分法（单调）

## 1.整数二分

```c++
int bin_search(int *a,int n,int x){
    int left=0,right=n;//不是n-1，此时左闭右开的
    while(left<right){
        int mid=(right+left)>>1;//最好
        if(a[mid]>=x)right=mid;
        else left=mid+1;
    }
    return left;
}
```

- bin_search()和STL的lower_bound()的功能是一样的。

- lower_bound(iterator first, iterator last, const T& value);作用：在 [first, last) 的有序区间中，返回第一个 ≥ value 的元素的位置。



若只是简单找x或x附近的数，就用upper_bound()和lower_bound()

![image-20260124183625752](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20260124183625752.png)

## 2.二分法建模：

```c++
while(left<right){
    int ans;
    int mid=(left+right)>>1;
    if(check(mid)){
        ans=mid;
        ...
    }
    else ...
}
```

有两个经典模型：最大值最小化、最小值最大化

## 3.【二分 + 最短路】完整模板版（标准通用）

> 适用于：
>  最大值最小化 + 路径可达性 + 权值约束

```
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const ll INF = 1e18;

int n, m;
ll b;
vector<ll> f;
vector<vector<pair<int,ll>>> g;

/*
check(mid)
含义：在最大城市费用 ≤ mid 的限制下，
是否存在一条从 1 到 n 的路径，使得总掉血 ≤ b
*/
bool check(ll mid) {
    if (f[1] > mid || f[n] > mid) return false;

    vector<ll> dist(n+1, INF);
    priority_queue<
        pair<ll,int>,
        vector<pair<ll,int>>,
        greater<pair<ll,int>>
    > pq;

    dist[1] = 0;
    pq.push({0, 1});

    while (!pq.empty()) {
        auto cur = pq.top(); pq.pop();
        ll d = cur.first;
        int u = cur.second;
        if (d > dist[u]) continue;

        for (auto e : g[u]) {
            int v = e.first;
            ll w = e.second;
            if (f[v] > mid) continue;

            if (dist[v] > d + w) {
                dist[v] = d + w;
                pq.push({dist[v], v});
            }
        }
    }
    return dist[n] <= b;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m >> b;

    f.resize(n+1);
    for (int i = 1; i <= n; i++) cin >> f[i];

    g.assign(n+1, {});
    for (int i = 0; i < m; i++) {
        int a, c;
        ll w;
        cin >> a >> c >> w;
        g[a].push_back({c, w});
        g[c].push_back({a, w});
    }

    ll l = max(f[1], f[n]);
    ll r = *max_element(f.begin()+1, f.end());

    if (!check(r)) {
        cout << "AFK";
        return 0;
    }

    while (l < r) {
        ll mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }

    cout << l;
}
```

------

### 4.【考试速抄版】20 行 check 模板（必背）

```
bool check(ll mid) {
    vector<ll> dist(n+1, INF);
    priority_queue<pair<ll,int>, vector<pair<ll,int>>, greater<pair<ll,int>>> pq;
    if (f[1] > mid || f[n] > mid) return false;

    dist[1] = 0;
    pq.push({0,1});

    while (!pq.empty()) {
        auto t = pq.top(); pq.pop();
        ll d = t.first;
        int u = t.second;
        if (d > dist[u]) continue;

        for (auto e : g[u]) {
            int v = e.first;
            ll w = e.second;
            if (f[v] > mid) continue;

            if (dist[v] > d + w) {
                dist[v] = d + w;
                pq.push({dist[v], v});
            }
        }
    }
    return dist[n] <= b;
}
```