# 🌱 入门动态规划（DP）通用模板

---

## 一、DP 四步固定法（核心口诀）

> **定义状态 → 初始化 → 状态转移 → 输出答案**

这是做任何 DP 题的第一步，记住这 4 步，你就有思路框架。

---

## 二、一维 DP 最通用模板

适用场景：

* 年份 / 天数 / 次数
* 累加问题
* 斐波那契 / 母牛 / 台阶 / 台阶延伸问题

```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;

    long long dp[1005] = {0};   // dp[i] 表示第 i 次 / 第 i 年 / 前 i 个的结果

    // 1. 初始化（根据题目给）
    dp[1] = 1;
    dp[2] = 2;
    dp[3] = 3;

    // 2. 状态转移
    for (int i = 4; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 3]; // ← 根据题目调整公式
    }

    // 3. 输出答案
    cout << dp[n] << endl;
    return 0;
}
```

---

## 三、常见一维 DP 问题模型

| 模型          | DP 公式                                             | 一句话描述                     | 典型题目                |                  |                |
| ----------- | ------------------------------------------------- | ------------------------- | ------------------- | ---------------- | -------------- |
| 斐波那契 / 台阶   | `dp[i] = dp[i-1] + dp[i-2]`                       | 当前状态只与前两项有关，总数等于前两项之和     | 斐波那契数列、兔子繁殖、走台阶     |                  |                |
| 母牛 / 延迟型    | `dp[i] = dp[i-1] + dp[i-k]`                       | 只有从 k 步前的状态才产生贡献          | 第 k 年后才繁殖的母牛问题      |                  |                |
| 最大值 / 最小值   | `dp[i] = max(dp[i-1], dp[i-2] + a[i])`            | 每一步要在“选”和“不选”之间取最优解       | 打家劫舍、区间最优问题         |                  |                |
| 累加型         | `dp[i] = dp[i-1] + f(i)`                          | 当前结果等于之前所有结果的累计，再加上当前项贡献  | 偶数平方和、奇数立方和、累计计数    |                  |                |
| 最少次数 / 步数   | `dp[i] = min(dp[i], dp[i-k] + 1)`                 | 每一步有代价，求达到目标的最少次数         | 最少硬币数、最少操作数、最少步数    |                  |                |
| 是否可达（布尔 DP） | `dp[i] = dp[i] \|\| dp[i-k]`            | 只关心状态是否能达到，不关心数量 | 能否凑出某个数、能否到达台阶 |
| 多步长方案数      | `dp[i] = dp[i-1] + ... + dp[i-k]`                 | 每一步可以选择多种步长，方案数为所有可行前置状态和 | 一次走 1~k 步的台阶、多种路径统计 |                  |                |
| 有限制状态       | `if(bad[i]) dp[i]=0; else dp[i]=dp[i-1]+dp[i-2];` | 某些状态不可用，遇到禁止状态直接失效        | 坏台阶、禁止位置、限制日期       |                  |                |
| 前缀最优型       | `dp[i] = max(a[i], dp[i-1]+a[i])`                 | 当前最优要么重新开始，要么在前一最优基础上扩展   | 最大子数组和、连续区间最优问题     |                  |                |
| 滚动变量优化      | `a=dp[i-2]; b=dp[i-1]; dp=a+b;`                   | 状态只依赖前若干项，可用常数变量降低空间      | 斐波那契、台阶问题（大 n）      |                  |                |

---

## 四、一维 DP 识别口诀

- **问方案数 → 加法**
- **问最少 / 最优 → min / max**
- **问能不能 → bool**
-  **有延迟 → i-k**
- **能跳多步 → 累加**
- **有禁止 → 清零**

---

## 五、总结

**一维 DP 核心思想 = 按顺序推，每一步只看过去若干状态，目标只有一个。**
看到题先问自己：
1. 当前状态可以用一个下标表示吗？
2. 它只依赖前面几项吗？
3. 是求总数 / 最优 / 是否可达 / 最少次数？
   这样就能快速套公式。


## 六、例题

| 题目 | 链接 | 题解 | 所属类型 |
|------|------|------|----------|
| 母牛的故事 | [题目](https://acm.hdu.edu.cn/showproblem.php?pid=2018) | [题解](../hdu-100/2018.cpp) | 母牛 / 延迟型 |
