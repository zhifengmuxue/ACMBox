# 单调队列 & 滑动窗口（模版,洛谷P1886）还能用于优化DP

长度为 `k` 的滑动窗口，在数组中从左到右移动，分别求每个窗口的最小值和最大值。



## 核心思想：单调队列是什么？

队列 `dq` **不存值，只存下标**⭐️（**由于deque支持随机访问**）并保证：

### 求最小值时：

- 队列中对应的值 **单调递增**
- 队首永远是当前窗口的最小值下标

### 求最大值时：

- 队列中对应的值 **单调递减**
- 队首永远是当前窗口的最大值下标

## 为什么队列里存的是“下标”，不是值？⭐️

因为你需要做两件事：

- **判断是否过期**（是否还在窗口内）
- **通过下标取数组值**

```
dq.front() <= i - k   // 是否已经滑出窗口
a[dq.front()]        // 当前窗口最值
```

## 第一部分：求每个窗口的最小值

```
for (int i = 1; i <= n; i++)
```

`i` 表示窗口右端点。

------

### ① 删除“过期元素”（不在窗口内的）

```
while (!dq.empty() && dq.front() <= i - k)
{
    dq.pop_front();
}
```

窗口范围是：

```
[i - k + 1 , i]
```

如果下标 `<= i - k`，说明已经不在窗口里，必须删掉。

------

### ② 维护“单调递增”队列（关键）

```
while (!dq.empty() && a[dq.back()] >= a[i])
    dq.pop_back();
```

含义：

- 新元素 `a[i]` **更小或一样小**
- 队尾那些 **比它大或相等的元素永远不可能成为最小值**
- 直接删掉

这样保证：

```
a[dq[0]] <= a[dq[1]] <= a[dq[2]] ...
```

------

### ③ 把当前下标加入队尾

```
dq.push_back(i);
```

------

### ④ 当窗口形成后，输出最小值

```
if (i >= k) {
    cout << a[dq.front()] << " ";
}
```

- `i < k`：窗口还没满
- `i >= k`：窗口合法
- 队首就是最小值

------

## 清空队列（为求最大值做准备）

```
while (!dq.empty()) dq.pop_front();
```

------

## 第二部分：求每个窗口的最大值

逻辑**完全一样，只是“方向相反”**。

------

### ① 删除过期元素（同上）

```
while (!dq.empty() && dq.front() <= i - k)
    dq.pop_front();
```

------

### ② 维护“单调递减”队列

```
while (!dq.empty() && a[dq.back()] <= a[i])
    dq.pop_back();
```

含义：

- 新元素更大
- 队尾那些更小的永远不可能成为最大值
- 删掉

保证：

```
a[dq[0]] >= a[dq[1]] >= a[dq[2]] ...
```

------

### ③ 入队 + 输出最大值

```
dq.push_back(i);

if (i >= k) {
    cout << a[dq.front()] << " ";
}
```

### 模板口诀⭐️

> **滑动窗口 + 单调队列**
>  1️⃣ 队列存下标
>  2️⃣ 先删过期（front）
>  3️⃣ 再删无用（back）
>  4️⃣ 队首即答案